on Debian 9, old libnss_mysql works like this:

/usr/lib/libnss_mysql.so.2
/usr/lib/libnss_mysql.so.2.0.0
/usr/lib/libnss_mysql.so.2.1.0

lrwxrwxrwx  1 root root   21 Aug 29  2017 libnss_mysql.so.2 -> libnss_mysql.so.2.0.0
-rwxr-xr-x  1 root root 137K Aug 29  2017 libnss_mysql.so.2.0.0
lrwxrwxrwx  1 root root   21 Aug 29  2017 libnss_mysql.so.2.1.0 -> libnss_mysql.so.2.0.0

/*
struct passwd {
  char    *pw_name;      // username
  char    *pw_passwd;    // user password
  uid_t    pw_uid;       // user ID
  gid_t    pw_gid;       // group ID
  char    *pw_gecos;     // user information
  char    *pw_dir;       // home directory
  char    *pw_shell;     // shell program
};
*/

enum nss_status
{
  NSS_STATUS_TRYAGAIN = -2,
  NSS_STATUS_UNAVAIL,
  NSS_STATUS_NOTFOUND,
  NSS_STATUS_SUCCESS,
  NSS_STATUS_RETURN
};


gdb --args getent passwd katarina
break passwd.c:39
break query.c:60
break group.c:229
run
info locals
info args
(gdb) p **gids@*gids_size
$5 = {9002, 21845, 0, 0, 1903393133, 1932420204, 7037807, 0, 48, 0}
break group.c:234

můžeš udělat něco jako #if sizeof(uid_t) == 4 [nový řádek] deklarace řetězce pro 4 bajty a podobně pro 8, případně si můžeš pro ostatní případy vyhodit chybu a zarazit kompilaci
19:58 > snprintf() writes at most `size` bytes (including the terminating null byte ('\0'))
#error "text chyby"


  MYSQL_STMT *stmt_conn = mysql_stmt_init(conn);

  if(!stmt_conn) {
    debug_print("mysql prepared statements init failed, out of memory");
    return NSS_STATUS_UNAVAIL;
  }

  if(mysql_stmt_prepare(stmt_conn, query, strlen(query))) {
    debug_print("mysql cannot prepare query for prepared statements");
    log_mysql_stmt_error(conn, stmt_conn);
    return NSS_STATUS_UNAVAIL;
  }

  if(mysql_stmt_param_count(stmt_conn) != 1) {
    debug_print("expected one parameter marker (?) in the query");
    return NSS_STATUS_UNAVAIL;
  }

  MYSQL_BIND bind[1];
  memset(bind, 0, sizeof(bind));

  bind[0].buffer_type = MYSQL_TYPE_STRING;
  bind[0].buffer = name;
  bind[0].buffer_length = strlen(name);
  bind[0].is_null = 0;
  //bind[0].length = strlen(name);

  if (mysql_stmt_bind_result(stmt_conn, bind)) {
    debug_print("cannot bind result");
    return NSS_STATUS_UNAVAIL;
  }

  if (mysql_stmt_execute(stmt_conn) != 0) {
    debug_print("_nss_maria_getpwnam_r cannot execute getpwnam mariadb query");
    log_mysql_error(conn);
    log_mysql_stmt_error(conn, stmt_conn);
    free(settings);
    return NSS_STATUS_UNAVAIL;
  }

  if (mysql_stmt_store_result(stmt_conn) != 0) {
    debug_print("_nss_maria_getpwnam_r cannot store getpwnam mariadb query");
    log_mysql_error(conn);
    log_mysql_stmt_error(conn, stmt_conn);
    free(settings);
    return NSS_STATUS_UNAVAIL;
  }



## far far in the future

- NSS_STATUS_NOTFOUND SUCCESS There are no entries. Use this to avoid returning errors for inactive services which may be enabled at a later time. This is not the same as the service being temporarily unavailable.
- NSS_SUCCESS should set errno to 0
- nss_maria_initgroups_dyn / gidsbymem propagate limit param to db query
